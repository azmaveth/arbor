defmodule Arbor.Core.StatefulExampleAgent do
  @moduledoc """
  An example agent that demonstrates the checkpoint behavior for 
  stateful agent recovery capabilities.

  This agent periodically saves its state and can recover from failures
  by restoring the last checkpoint.
  """

  use Arbor.Core.AgentBehavior

  # Note: Dialyzer warnings for defensive error handling generated by AgentBehavior
  # are handled with function-specific suppressions below

  # Suppress warnings for legacy checkpoint functions that handle impossible error cases
  @dialyzer [
    {:nowarn_function, extract_checkpoint_data: 1},
    {:nowarn_function, restore_from_checkpoint: 2}
  ]

  alias Arbor.Core.AgentCheckpoint
  require Logger

  # Client API

  @spec start_link(keyword()) :: GenServer.on_start()
  def start_link(args) do
    GenServer.start_link(__MODULE__, args)
  end

  @spec increment_counter(pid()) :: :ok
  def increment_counter(pid) do
    GenServer.cast(pid, :increment)
  end

  @spec set_value(pid(), any(), any()) :: :ok
  def set_value(pid, key, value) do
    GenServer.cast(pid, {:set_value, key, value})
  end

  @spec get_state(pid()) :: map()
  def get_state(pid) do
    GenServer.call(pid, :get_state)
  end

  @spec save_checkpoint_now(pid()) :: :ok
  def save_checkpoint_now(pid) do
    GenServer.cast(pid, :checkpoint)
  end

  # GenServer callbacks

  @impl GenServer
  def init(args) do
    agent_id = Keyword.get(args, :agent_id)
    _agent_metadata = Keyword.get(args, :agent_metadata, %{})
    recovered_state = Keyword.get(args, :recovered_state)

    # Try to load from checkpoint if no recovered state provided
    state =
      case recovered_state do
        nil ->
          # Try to load from checkpoint
          case AgentCheckpoint.load_checkpoint(agent_id) do
            {:ok, checkpoint_data} ->
              Logger.info("StatefulExampleAgent #{agent_id} loaded checkpoint during init",
                counter: checkpoint_data.counter
              )

              %{
                agent_id: agent_id,
                counter: checkpoint_data.counter,
                data: checkpoint_data.data,
                started_at: System.system_time(:millisecond),
                checkpoint_count: checkpoint_data.checkpoint_count,
                recovered: true
              }

            {:error, :not_found} ->
              Logger.info("StatefulExampleAgent #{agent_id} starting fresh (no checkpoint)")

              %{
                agent_id: agent_id,
                counter: 0,
                data: %{},
                started_at: System.system_time(:millisecond),
                checkpoint_count: 0,
                recovered: false
              }
          end

        recovered ->
          Logger.info("StatefulExampleAgent #{agent_id} restored from provided state",
            counter: recovered.counter,
            checkpoint_count: recovered.checkpoint_count
          )

          %{recovered | started_at: System.system_time(:millisecond), recovered: true}
      end

    # Note: Agent registration is now handled by HordeSupervisor (centralized)

    # Enable automatic checkpointing every 10 seconds
    AgentCheckpoint.enable_auto_checkpoint(self(), 10_000)

    Logger.info("StatefulExampleAgent #{agent_id} initialized",
      recovered: state.recovered,
      counter: state.counter
    )

    {:ok, state, {:continue, :register_with_supervisor}}
  end

  def get_agent_metadata(state) do
    %{
      type: :stateful_example,
      counter: state.counter,
      recovered: state.recovered,
      checkpoint_count: state.checkpoint_count,
      started_at: state.started_at
    }
  end

  @impl GenServer
  def handle_cast(:increment, state) do
    new_state = %{state | counter: state.counter + 1}
    Logger.debug("Incremented counter to #{new_state.counter}")
    {:noreply, new_state}
  end

  @impl GenServer
  def handle_cast({:set_value, key, value}, state) do
    new_data = Map.put(state.data, key, value)
    new_state = %{state | data: new_data}
    Logger.debug("Set #{key} to #{inspect(value)}")
    {:noreply, new_state}
  end

  @impl GenServer
  def handle_cast(:checkpoint, state) do
    # save_checkpoint always returns :ok according to its spec
    :ok = AgentCheckpoint.save_checkpoint(state.agent_id, state)

    new_state = %{state | checkpoint_count: state.checkpoint_count + 1}
    Logger.debug("Saved checkpoint #{new_state.checkpoint_count} for agent #{state.agent_id}")

    # Schedule next automatic checkpoint
    AgentCheckpoint.enable_auto_checkpoint(self(), 10_000)

    {:noreply, new_state}
  end

  @impl GenServer
  def handle_call(:get_state, _from, state) do
    {:reply, state, state}
  end

  @impl GenServer
  def handle_call(:prepare_checkpoint, _from, state) do
    # Extract checkpoint data for migration/restore
    checkpoint_data = extract_checkpoint_data(state)
    {:reply, checkpoint_data, state}
  end

  @impl GenServer
  def handle_info(:checkpoint, state) do
    # Handle automatic checkpoint trigger
    handle_cast(:checkpoint, state)
  end

  @impl GenServer
  def handle_info(msg, state) do
    Logger.debug("StatefulExampleAgent received unexpected message: #{inspect(msg)}")
    {:noreply, state}
  end

  @impl GenServer
  def terminate(_reason, state) do
    # Save final checkpoint (registration cleanup handled by HordeSupervisor)
    if state.agent_id do
      AgentCheckpoint.save_checkpoint(state.agent_id, state)
    end

    Logger.info("StatefulExampleAgent #{state.agent_id} terminated")
    :ok
  end

  # AgentBehavior callback implementations

  def extract_state(state) do
    # Return only essential state data (exclude runtime metadata)
    checkpoint_data = %{
      agent_id: state.agent_id,
      counter: state.counter,
      data: state.data,
      checkpoint_count: state.checkpoint_count,
      last_checkpoint: System.system_time(:millisecond)
    }

    {:ok, checkpoint_data}
  end

  def restore_state(_agent_spec, checkpoint_data) do
    # Reconstruct full state from checkpoint data
    # Use Map.get to safely access keys
    restored_state = %{
      agent_id: Map.get(checkpoint_data, :agent_id),
      counter: Map.get(checkpoint_data, :counter, 0),
      data: Map.get(checkpoint_data, :data, %{}),
      checkpoint_count: Map.get(checkpoint_data, :checkpoint_count, 0),
      started_at: Map.get(checkpoint_data, :last_checkpoint, System.system_time(:millisecond)),
      recovered: true,
      recovered_at: System.system_time(:millisecond)
    }

    {:ok, restored_state}
  end

  # Legacy checkpoint functions for backward compatibility
  # Note: These functions handle error cases even though our implementation
  # of extract_state and restore_state never fail. This is for API compatibility.

  @spec extract_checkpoint_data(state :: map()) :: map()
  def extract_checkpoint_data(state) do
    {:ok, data} = extract_state(state)
    data
  end

  @spec restore_from_checkpoint(checkpoint_data :: map(), current_state :: map()) :: map()
  def restore_from_checkpoint(checkpoint_data, current_state) do
    {:ok, state} = restore_state(current_state, checkpoint_data)
    state
  end
end
